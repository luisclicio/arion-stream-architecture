import type { ProcessorBaseData } from './types/index.js';
import { env } from './env.js';
import { logger } from './services/logger.js';
import { brokerClient } from './services/broker.js';
import { getSeverityLevel } from './libs/classifier.js';
import { benchmarkDataSaver } from './services/benchmark.js';
import { Clock } from './services/clock.js';

async function main() {
  const BROKER_EXCHANGE_NAME = env.BROKER_RABBITMQ_EXCHANGE_NAME;

  await brokerClient.setupChannel(async (channel) => {
    await channel.assertExchange(BROKER_EXCHANGE_NAME, 'topic', {
      durable: true,
    });

    // Queue for receiving all analyses generated by stream processors
    await channel.assertQueue('arion-classifiers-analyses-all', {
      durable: true,
    });
    await channel.bindQueue(
      'arion-classifiers-analyses-all',
      BROKER_EXCHANGE_NAME,
      'arion.processors.analyses.#',
    );

    await channel.prefetch(1); // Process one message at a time
  });

  brokerClient.consumeFromQueue<ProcessorBaseData>(
    'arion-classifiers-analyses-all',
    async ({ data }) => {
      // NOTE: BENCHMARK POINT
      const receivedDataTimestamp = await Clock.now();
      const receivedDataLatency =
        receivedDataTimestamp.getTime() -
        new Date(data.benchmark.processor.sending_data_timestamp).getTime(); // ms

      try {
        logger.info(data, 'Making classification based on analysis');

        // Make a classification based on the analysis
        const severity = getSeverityLevel(data);

        logger.debug({ severity }, 'Classification made based on analysis');

        const sendingDataTimestamp = await Clock.now();
        const benchmarkData = {
          adapter: {
            ...data.benchmark.adapter,
            sending_image_timestamp: new Date(
              data.benchmark.adapter.sending_image_timestamp,
            ),
          },
          processor: {
            ...data.benchmark.processor,
            received_image_timestamp: new Date(
              data.benchmark.processor.received_image_timestamp,
            ),
            sending_data_timestamp: new Date(
              data.benchmark.processor.sending_data_timestamp,
            ),
          },
          classifier: {
            service_name: env.SERVICE_NAME,
            received_data_timestamp: receivedDataTimestamp,
            received_data_latency: receivedDataLatency,
            sending_data_timestamp: sendingDataTimestamp,
          },
        };

        await brokerClient.publishToExchange(
          BROKER_EXCHANGE_NAME,
          `arion.classifiers.analyses.${data.model.name}.${severity}`,
          {
            ...data,
            severity,
            benchmark: benchmarkData,
          },
        );

        const dataToSave = {
          metadata: {
            timestamp: await Clock.now(),
            service_type: env.SERVICE_TYPE,
            stack_id: env.STACK_ID,
          },
          ...benchmarkData,
        };
        await benchmarkDataSaver.save(dataToSave);

        return { canAcknowledge: true };
      } catch (error) {
        logger.error(error, 'Failed to make classification based on analysis');
        return { canAcknowledge: false };
      }
    },
  );

  logger.info('The service has started successfully');
}

async function gracefulShutdown(exitCode = 0) {
  try {
    await brokerClient.close();
  } finally {
    process.exit(exitCode);
  }
}

main().catch(async (error) => {
  logger.fatal(error, 'Failed to start the service');
  await gracefulShutdown(1);
});

process.on('uncaughtException', async (error) => {
  logger.fatal(error, 'Uncaught exception detected');
  await gracefulShutdown(1);
});

process.on('unhandledRejection', async (error) => {
  logger.fatal(error, 'Unhandled promise rejection detected');
  await gracefulShutdown(1);
});

process.on('SIGINT', async () => {
  logger.info('Received SIGINT signal');
  await gracefulShutdown();
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM signal');
  await gracefulShutdown();
});
