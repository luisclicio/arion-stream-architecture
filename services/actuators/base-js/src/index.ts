import fs from 'node:fs/promises';

import { env } from './env.js';
import { logger } from './services/logger.js';
import { brokerClient } from './services/broker.js';

async function main() {
  const PROCESSORS_N = 1;
  const evaluationT2CsvFilePath = `/benchmarks/actuators/evaluation_t2_${PROCESSORS_N}p_${Date.now()}.csv`;
  const evaluationT2CsvHeader = 'time_diff_ms,timestamp_start,timestamp_end\n';

  await fs.mkdir('/benchmarks/actuators', { recursive: true });
  await fs.writeFile(evaluationT2CsvFilePath, evaluationT2CsvHeader);

  const BROKER_EXCHANGE_NAME = env.BROKER_RABBITMQ_EXCHANGE_NAME;

  await brokerClient.setupChannel(async (channel) => {
    await channel.assertExchange(BROKER_EXCHANGE_NAME, 'topic', {
      durable: true,
    });

    // Queue for receiving all analyses generated by classifiers services
    await channel.assertQueue('arion-actuators-analyses-all', {
      durable: true,
    });
    await channel.bindQueue(
      'arion-actuators-analyses-all',
      BROKER_EXCHANGE_NAME,
      'arion.classifiers.analyses.#',
    );

    await channel.prefetch(1); // Process one message at a time
  });

  brokerClient.consumeFromQueue(
    'arion-actuators-analyses-all',
    async ({ data }) => {
      try {
        const timestampEnd = Date.now();
        const timestampStart = Date.parse(data.timestamp);
        const timeDiff = timestampEnd - timestampStart;

        await fs.appendFile(
          evaluationT2CsvFilePath,
          `${timeDiff},${timestampStart},${timestampEnd}\n`,
        );

        logger.info(data, 'Making action based on classified analysis');
        return { canAcknowledge: true };
      } catch (error) {
        logger.error(
          error,
          'Failed to make action based on classified analysis',
        );
        return { canAcknowledge: false };
      }
    },
  );

  logger.info('The service has started successfully');
}

async function gracefulShutdown(exitCode = 0) {
  try {
    await brokerClient.close();
  } finally {
    process.exit(exitCode);
  }
}

main().catch(async (error) => {
  logger.fatal(error, 'Failed to start the service');
  await gracefulShutdown(1);
});

process.on('uncaughtException', async (error) => {
  logger.fatal(error, 'Uncaught exception detected');
  await gracefulShutdown(1);
});

process.on('unhandledRejection', async (error) => {
  logger.fatal(error, 'Unhandled promise rejection detected');
  await gracefulShutdown(1);
});

process.on('SIGINT', async () => {
  logger.info('Received SIGINT signal');
  await gracefulShutdown();
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM signal');
  await gracefulShutdown();
});
