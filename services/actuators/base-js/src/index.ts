import type { ProcessorBaseData } from './types/index.js';
import { env } from './env.js';
import { logger } from './services/logger.js';
import { brokerClient } from './services/broker.js';
import { benchmarkDataSaver } from './services/benchmark.js';

async function main() {
  const BROKER_EXCHANGE_NAME = env.BROKER_RABBITMQ_EXCHANGE_NAME;

  await brokerClient.setupChannel(async (channel) => {
    await channel.assertExchange(BROKER_EXCHANGE_NAME, 'topic', {
      durable: true,
    });

    // Queue for receiving all analyses generated by classifiers services
    await channel.assertQueue('arion-actuators-analyses-all', {
      durable: true,
    });
    await channel.bindQueue(
      'arion-actuators-analyses-all',
      BROKER_EXCHANGE_NAME,
      'arion.classifiers.analyses.#',
    );

    await channel.prefetch(1); // Process one message at a time
  });

  brokerClient.consumeFromQueue<ProcessorBaseData>(
    'arion-actuators-analyses-all',
    async ({ data }) => {
      const receivedDataTimestamp = new Date();
      const receivedDataLatency =
        receivedDataTimestamp.getTime() -
        new Date(data.benchmark.classifier.sending_data_timestamp).getTime(); // ms

      try {
        logger.info(data, 'Making action based on classified analysis');

        const benchmarkData = {
          adapter: {
            ...data.benchmark.adapter,
            sending_image_timestamp: new Date(
              data.benchmark.adapter.sending_image_timestamp,
            ),
          },
          processor: {
            ...data.benchmark.processor,
            received_image_timestamp: new Date(
              data.benchmark.processor.received_image_timestamp,
            ),
            sending_data_timestamp: new Date(
              data.benchmark.processor.sending_data_timestamp,
            ),
          },
          classifier: {
            ...data.benchmark.classifier,
            received_data_timestamp: new Date(
              data.benchmark.classifier.received_data_timestamp,
            ),
            sending_data_timestamp: new Date(
              data.benchmark.classifier.sending_data_timestamp,
            ),
          },
          actuator: {
            service_name: env.SERVICE_NAME,
            received_data_timestamp: receivedDataTimestamp,
            received_data_latency: receivedDataLatency,
          },
        };
        const dataToSave = {
          metadata: {
            timestamp: new Date(),
            service_type: env.SERVICE_TYPE,
            stack_id: env.STACK_ID,
          },
          ...benchmarkData,
        };
        await benchmarkDataSaver.save(dataToSave);

        return { canAcknowledge: true };
      } catch (error) {
        logger.error(
          error,
          'Failed to make action based on classified analysis',
        );
        return { canAcknowledge: false };
      }
    },
  );

  logger.info('The service has started successfully');
}

async function gracefulShutdown(exitCode = 0) {
  try {
    await brokerClient.close();
  } finally {
    process.exit(exitCode);
  }
}

main().catch(async (error) => {
  logger.fatal(error, 'Failed to start the service');
  await gracefulShutdown(1);
});

process.on('uncaughtException', async (error) => {
  logger.fatal(error, 'Uncaught exception detected');
  await gracefulShutdown(1);
});

process.on('unhandledRejection', async (error) => {
  logger.fatal(error, 'Unhandled promise rejection detected');
  await gracefulShutdown(1);
});

process.on('SIGINT', async () => {
  logger.info('Received SIGINT signal');
  await gracefulShutdown();
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM signal');
  await gracefulShutdown();
});
